# DOCUMENTATION

## CreepWrapper

`CreepWrapper` предоставляет более удобный интерфейс поверх стандартного объекта `Creep` из Screeps. Обёртка скрывает детали работы с памятью, перемещением и энергией, позволяя сосредоточиться на логике поведения.

### Ключевые возможности
- Быстрый доступ к памяти и имени крипа без прямого обращения к исходному объекту.
- Поиск ближайших целей разных типов (`source`, `enemy`, `controller`, `spawn`, `constructionSite`) с обработкой ситуаций, когда игровой API недоступен (например, в тестах).
- Единый интерфейс для перемещения: методы `moveTo` и `moveCloseTo` автоматически задают стиль визуализации пути, чтобы перемещения отображались в реплеях.
- Упрощённая работа с энергохранилищем крипа через объект `storage`, включающий проверки заполненности, чтение текущих значений и проксирование операций `harvest`, `pickup`, `transfer`.

### Работа с запасами энергии
Интерфейс `CreepEnergyStorage` предоставляет методы `isFull`, `isEmpty`, `getEnergy`, `getFreeCapacity`, `getCapacity` и `getFillRatio`, что позволяет без дополнительных расчётов оценивать запас и свободное место. Дополнительно доступны операции пополнения и передачи энергии, которые вызывают базовые методы Screeps на обёрнутом `Creep`.

### Поиск целей и перемещение
Метод `findClosest` принимает тип цели и возвращает ближайший объект или `null`, если подходящей цели нет. Для контроллера используется прямой доступ через `creep.room.controller`. Команды движения (`moveTo`, `moveCloseTo`) перед вызовом `moveTo` исходного объекта проверяют расстояние до цели и задают стиль визуализации пути (`DEFAULT_PATH_STYLE`), чтобы траектория была видимой в клиенте.

### Использование
Обёртку следует создавать для существующего `Creep`. Пример: `const wrapper = new CreepWrapper(creep);`. Далее можно использовать методы `wrapper.storage.isFull()`, `wrapper.findClosest('source')` или `wrapper.moveCloseTo(target, 1)` для построения поведения без прямого обращения к низкоуровневому API.

## Runner

`Runner` отвечает за координацию популяции крипов в одной комнате и предоставляет удобные методы для обслуживания рутинных задач, связанных со спавном и перебором юнитов.

### Управление популяцией
Метод `maintainCreepPopulation` проверяет количество крипов заданного типа и уровня, и при необходимости инициирует спавн на свободной постройке `StructureSpawn` в комнате. Имена крипов формируются по схеме `<Role>-<Level>-<Game.time>`, а в память записываются роль, уровень и целевая комната.

### Итерация по крипам
Метод `forEachCreepOfType` перебирает все обёртки `CreepWrapper`, соответствующие указанному типу (и необязательному уровню), и вызывает переданный обработчик. Это устраняет необходимость вручную фильтровать `Game.creeps` и повторно создавать обёртки.

### Кэширующий слой
`Runner` ведёт карту обёрток, синхронизируя её с фактическим набором крипов. При изменении состава юнитов кэш обновляется: отсутствующие экземпляры удаляются, а новые создаются на основе `CreepWrapper`.

### Корпуса по умолчанию
В момент создания раннер регистрирует стандартные конфигурации тел (`BodyPartConstant[]`) для базовых ролей (`Harvester`, `Upgrader`, `Builder`) и нескольких уровней. Если требуется особая конфигурация, её можно добавить в `bodyDefinitions` до вызова `maintainCreepPopulation`, используя закрытый метод `createBodyKey` в качестве шаблона ключа.

### Применение
Создайте экземпляр `Runner` для комнаты: `const runner = new Runner('W0N0');`. Затем вызовите `runner.maintainCreepPopulation(CreepType.Harvester, 1, 2)` для поддержания двух харвестеров первого уровня и используйте `runner.forEachCreepOfType` для выполнения логики поведения над каждым крипом.
